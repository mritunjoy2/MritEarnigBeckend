{
  "name": "mrit-earing-backend",
  "version": "1.1.0",
  "type": "module",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.1.5",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.4.0"
  },
  "devDependencies": {
    "nodemon": "^3.1.0"
  }
}import 'dotenv/config';
import express from 'express';
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import cors from 'cors';
import rateLimit from 'express-rate-limit';

const app = express();
app.use(cors());
app.use(express.json());
app.use(rateLimit({ windowMs: 15*60*1000, max: 300 }));

const PORT = process.env.PORT || 4000;
const MONGO_URI = process.env.MONGO_URI;
const JWT_SECRET = process.env.JWT_SECRET || 'change_me';
const SALT_ROUNDS = 10;
const REFERRER_REWARD = Number(process.env.REFERRER_REWARD || 10);
const REFEREE_REWARD = Number(process.env.REFEREE_REWARD || 10);
const MIN_WITHDRAW = Number(process.env.MIN_WITHDRAW || 100);

if (!MONGO_URI) {
  console.error('MONGO_URI missing. Set it in env vars.');
  process.exit(1);
}

await mongoose.connect(MONGO_URI);
const { Schema, model } = mongoose;

const UserSchema = new Schema({
  name: String,
  email: { type: String, unique: true, index: true },
  password_hash: String,
  role: { type: String, default: 'user' },
  wallet_balance: { type: Number, default: 0 },
  ref_code: { type: String, unique: true, sparse: true }
}, { timestamps: true });

const TaskSchema = new Schema({
  title: String,
  reward: { type: Number, default: 5 },
  active: { type: Boolean, default: true }
}, { timestamps: true });

const SurveySchema = new Schema({
  title: String,
  reward: { type: Number, default: 5 },
  active: { type: Boolean, default: true }
}, { timestamps: true });

const WithdrawalSchema = new Schema({
  user_id: { type: Schema.Types.ObjectId, ref: 'User' },
  amount: Number,
  status: { type: String, default: 'pending' }, // pending, approved, rejected, paid
  note: String,
  created_at: { type: Date, default: Date.now },
  processed_at: Date
});

const ReferralSchema = new Schema({
  referrer_id: { type: Schema.Types.ObjectId, ref: 'User' },
  referee_id: { type: Schema.Types.ObjectId, ref: 'User' },
  code_used: String,
  status: { type: String, default: 'pending' }, // pending, confirmed, rejected
  created_at: { type: Date, default: Date.now },
  confirmed_at: Date
});
ReferralSchema.index({ referee_id: 1 }, { unique: true, sparse: true });

const User = model('User', UserSchema);
const Task = model('Task', TaskSchema);
const Survey = model('Survey', SurveySchema);
const Withdrawal = model('Withdrawal', WithdrawalSchema);
const Referral = model('Referral', ReferralSchema);

function signToken(user) {
  return jwt.sign({ id: user._id, role: user.role }, JWT_SECRET, { expiresIn: '7d' });
}
function auth(req, res, next) {
  const h = req.headers.authorization;
  if (!h) return res.status(401).json({ error: 'Unauthorized' });
  const token = h.split(' ')[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.userId = payload.id;
    req.userRole = payload.role;
    next();
  } catch {
    return res.status(401).json({ error: 'Invalid token' });
  }
}
function adminOnly(req, res, next) {
  if (req.userRole !== 'admin') return res.status(403).json({ error: 'Admin only' });
  next();
}

// bootstrap admin
(async () => {
  const adminEmail = process.env.ADMIN_EMAIL || 'admin@mrit.local';
  const adminPass = process.env.ADMIN_PASSWORD || 'admin123';
  const existing = await User.findOne({ email: adminEmail });
  if (!existing) {
    const hash = await bcrypt.hash(adminPass, SALT_ROUNDS);
    await User.create({ name: 'Admin', email: adminEmail, password_hash: hash, role: 'admin', ref_code: 'ADMIN' });
    console.log('Admin created:', adminEmail);
  } else {
    console.log('Admin exists:', adminEmail);
  }
})().catch(console.error);

// health
app.get('/health', (req,res)=>res.json({ ok:true }));

// auth
app.post('/auth/register', async (req,res)=>{
  const { name, email, password, ref } = req.body || {};
  if (!email || !password) return res.status(400).json({ error: 'Missing email/password' });
  const exists = await User.findOne({ email });
  if (exists) return res.status(400).json({ error: 'Email already exists' });
  const hash = await bcrypt.hash(password, SALT_ROUNDS);
  const ref_code = 'ME' + Math.floor(Math.random()*90000 + 10000);
  const user = await User.create({ name, email, password_hash: hash, ref_code });
  if (ref) {
    const referrer = await User.findOne({ ref_code: ref });
    if (referrer && String(referrer._id) !== String(user._id)) {
      await Referral.create({ referrer_id: referrer._id, referee_id: user._id, code_used: ref, status: 'pending' });
    }
  }
  const token = signToken(user);
  res.json({ token, user: { id:user._id, name:user.name, email:user.email, wallet_balance:user.wallet_balance, ref_code } });
});

app.post('/auth/login', async (req,res)=>{
  const { email, password } = req.body || {};
  const user = await User.findOne({ email });
  if (!user) return res.status(400).json({ error: 'Invalid credentials' });
  const ok = await bcrypt.compare(password, user.password_hash);
  if (!ok) return res.status(400).json({ error: 'Invalid credentials' });
  const token = signToken(user);
  res.json({ token, user: { id:user._id, name:user.name, email:user.email, wallet_balance:user.wallet_balance, ref_code:user.ref_code } });
});

// public lists
app.get('/tasks', async (req,res)=>{
  const tasks = await Task.find({ active: true }).sort({ createdAt: -1 }).lean();
  res.json({ tasks });
});
app.get('/surveys', async (req,res)=>{
  const surveys = await Survey.find({ active: true }).sort({ createdAt: -1 }).lean();
  res.json({ surveys });
});

// user wallet & referrals
app.get('/wallet', auth, async (req,res)=>{
  const u = await User.findById(req.userId).lean();
  const withdrawals = await Withdrawal.find({ user_id: req.userId }).sort({ created_at: -1 }).lean();
  const referrals = await Referral.find({ referrer_id: req.userId, status: 'confirmed' }).lean();
  const pendingRef = await Referral.find({ referrer_id: req.userId, status: 'pending' }).countDocuments();
  res.json({
    balance: u?.wallet_balance || 0,
    withdrawals,
    referral_stats: { confirmed: referrals.length, pending: pendingRef, reward_each: REFERRER_REWARD }
  });
});

app.post('/withdraw', auth, async (req,res)=>{
  const amt = Number((req.body && req.body.amount) || 0);
  if (amt <= 0) return res.status(400).json({ error: 'Invalid amount' });
  const u = await User.findById(req.userId);
  if ((u.wallet_balance || 0) < amt) return res.status(400).json({ error: 'Insufficient balance' });
  if (amt < MIN_WITHDRAW) return res.status(400).json({ error: `Minimum withdraw is ₹${MIN_WITHDRAW}` });
  await Withdrawal.create({ user_id: u._id, amount: amt, status: 'pending' });
  u.wallet_balance -= amt;
  await u.save();
  res.json({ ok:true, message: 'Withdrawal requested' });
});

// Task completion + referral confirm
const UserTaskSchema = new Schema({
  user_id: { type: Schema.Types.ObjectId, ref: 'User' },
  task_id: { type: Schema.Types.ObjectId, ref: 'Task' },
  survey_id: { type: Schema.Types.ObjectId, ref: 'Survey' },
  completed_at: { type: Date, default: Date.now }
});
UserTaskSchema.index({ user_id:1, task_id:1, survey_id:1 }, { unique: true, sparse: true });
const UserTask = model('UserTask', UserTaskSchema);

async function confirmReferralIfFirst(userId) {
  const count = await UserTask.countDocuments({ user_id: userId });
  if (count === 1) {
    const ref = await Referral.findOne({ referee_id: userId, status: 'pending' });
    if (ref) {
      await User.findByIdAndUpdate(ref.referrer_id, { $inc: { wallet_balance: REFERRER_REWARD } });
      await User.findByIdAndUpdate(ref.referee_id, { $inc: { wallet_balance: REFEREE_REWARD } });
      ref.status = 'confirmed';
      ref.confirmed_at = new Date();
      await ref.save();
    }
  }
}

app.post('/tasks/:id/complete', auth, async (req,res)=>{
  const task = await Task.findById(req.params.id);
  if (!task) return res.status(404).json({ error: 'Task not found' });
  const exists = await UserTask.findOne({ user_id: req.userId, task_id: task._id });
  if (exists) return res.status(400).json({ error: 'Already completed' });
  await UserTask.create({ user_id: req.userId, task_id: task._id });
  await User.findByIdAndUpdate(req.userId, { $inc: { wallet_balance: task.reward } });
  await confirmReferralIfFirst(req.userId);
  res.json({ ok:true, message: `Credited ₹${task.reward}` });
});

app.post('/surveys/:id/complete', auth, async (req,res)=>{
  const s = await Survey.findById(req.params.id);
  if (!s) return res.status(404).json({ error: 'Survey not found' });
  const exists = await UserTask.findOne({ user_id: req.userId, survey_id: s._id });
  if (exists) return res.status(400).json({ error: 'Already completed' });
  await UserTask.create({ user_id: req.userId, survey_id: s._id });
  await User.findByIdAndUpdate(req.userId, { $inc: { wallet_balance: s.reward } });
  await confirmReferralIfFirst(req.userId);
  res.json({ ok:true, message: `Credited ₹${s.reward}` });
});

// admin
app.post('/admin/tasks', auth, adminOnly, async (req,res)=>{
  const { title, reward } = req.body || {};
  const t = await Task.create({ title, reward });
  res.json({ ok:true, task: t });
});
app.post('/admin/surveys', auth, adminOnly, async (req,res)=>{
  const { title, reward } = req.body || {};
  const s = await Survey.create({ title, reward });
  res.json({ ok:true, survey: s });
});
app.get('/admin/referrals', auth, adminOnly, async (req,res)=>{
  const list = await Referral.find().sort({ created_at: -1 }).lean();
  res.json({ list });
});
app.get('/admin/withdrawals', auth, adminOnly, async (req,res)=>{
  const list = await Withdrawal.find().sort({ created_at: -1 }).lean();
  res.json({ list });
});
app.post('/admin/withdrawals/:id/process', auth, adminOnly, async (req,res)=>{
  const { action } = req.body || {};
  const wd = await Withdrawal.findById(req.params.id);
  if (!wd) return res.status(404).json({ error: 'Not found' });
  if (action === 'reject') {
    wd.status = 'rejected'; wd.processed_at = new Date(); await wd.save();
    await User.findByIdAndUpdate(wd.user_id, { $inc: { wallet_balance: wd.amount } });
  } else if (action === 'approve') {
    wd.status = 'approved'; wd.processed_at = new Date(); await wd.save();
  } else if (action === 'paid') {
    wd.status = 'paid'; wd.processed_at = new Date(); await wd.save();
  } else {
    return res.status(400).json({ error: 'Invalid action' });
  }
  res.json({ ok:true });
});
PORT=4000
MONGO_URI=<paste your Atlas URI here>
JWT_SECRET=ChangeMeStrongSecret
ADMIN_EMAIL=admin@mrit.local
ADMIN_PASSWORD=StrongAdminPassword123
REFERRER_REWARD=10
REFEREE_REWARD=10
MIN_WITHDRAW=100
app.listen(PORT, ()=>console.log('Server running on port', PORT));# Mrit Earing Backend
- Referral: ₹10 + ₹10 on first task
- Min withdraw: ₹100

## Deploy (Render)
Build: npm install
Start: npm start
Env Vars: see .env.example
Routes: /auth/register, /auth/login, /tasks, /surveys, /tasks/:id/complete, /surveys/:id/complete, /wallet, /withdraw, /admin/*
